#include <AccelStepper.h>
#include <Arduino.h>
#include <ArduinoJson.h>
#include <ESP32Servo.h>
#include <Wire.h>

#include "HeartRateBLE.h"

HeartRateBLE hrBle;
// HeartRateBLE heartRate("e2:03:b2:52:c1:3f"); // MAC thi·∫øt b·ªã BLE

void onData(int bpm, int battery) {
  Serial.printf("üëâ [CALLBACK] BPM=%d | Battery=%d%%\n", bpm, battery);
}

void onConnect(bool connected) {
  if (connected)
    Serial.println("üü¢ ƒê√£ k·∫øt n·ªëi BLE!");
  else
    Serial.println("üî¥ M·∫•t k·∫øt n·ªëi BLE!");
}

void bluetooth_init() {
  Serial.println("=== ESP32 BLE Heart Rate (Auto + Direct) ===");

  hrBle.begin();
  hrBle.setDataCallback(onData);
  hrBle.setConnectCallback(onConnect);
  hrBle.setAutoReconnect(true, 5);

  // ‚úÖ K·∫øt n·ªëi tr·ª±c ti·∫øp (b·ªè qua qu√©t)
  if (!hrBle.connectDirect("c7:f9:08:e7:fe:1b", BLE_ADDR_TYPE_RANDOM)) {
    Serial.println("‚ö†Ô∏è Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c, th·ª≠ qu√©t...");
    hrBle.scanHeartRate(10);
    hrBle.connectToDevice();
  }
}

// ==================== BOARD: ESP32 DevKit v1 (30-pin) ====================
// CPU: ESP32-WROOM-32
// Flash: 4MB
// GPIO: 30 pins available (tr√°nh strapping pins)

// ==================== I2C CONFIGURATION ====================
#define I2C_SLAVE_ADDR 0x55
#define I2C_SDA_PIN 21 // Default I2C SDA (safe)
#define I2C_SCL_PIN 22 // Default I2C SCL (safe)

// ==================== STRAPPING PINS (TR√ÅNH KHI C√ì TH·ªÇ) ====================
// GPIO 0  : Boot mode (LOW = download mode) - C√ì TH·ªÇ d√πng sau khi boot
// GPIO 2  : Boot mode (must be LOW/floating at boot) - C√ì TH·ªÇ d√πng sau boot
// GPIO 5  : Timing of SDIO slave (safe for output)
// GPIO 12 : MTDI Flash voltage (LOW=3.3V, HIGH=1.8V) - TR√ÅNH n·∫øu c√≥ th·ªÉ
// GPIO 15 : MTDO Timing (must be HIGH at boot) - C√ì TH·ªÇ d√πng n·∫øu pull-up

// ==================== STEPPER MOTOR PINS ====================
// S·ª≠ d·ª•ng DRV8825 ho·∫∑c A4988 stepper drivers
// 4 motors cho Mecanum wheels: FL, FR, BL, BR

// EN (Enable) pin chung cho t·∫•t c·∫£ motors
#define MOTOR_EN 33 // GPIO33 - Safe, no conflicts

// Motor FL (Front Left)
#define MOTOR_FL_STEP 26 // GPIO26 - Safe
#define MOTOR_FL_DIR 25  // GPIO25 - Safe

// Motor FR (Front Right)
#define MOTOR_FR_STEP 14 // GPIO14 - Safe
#define MOTOR_FR_DIR 27  // GPIO27 - Safe

// Motor BL (Back Left)
#define MOTOR_BL_STEP 13 // GPIO13 - Safe
#define MOTOR_BL_DIR 32  // GPIO32 - Safe (ADC but can be output)

// Motor BR (Back Right)
#define MOTOR_BR_STEP 4 // GPIO4 - Safe
#define MOTOR_BR_DIR 16 // GPIO16 - Safe (U1RXD but can reuse)

// Stepper motor configuration
#define MAX_SPEED 2000.0     // steps/sec
#define ACCELERATION 1000.0  // steps/sec^2
#define DEFAULT_SPEED 1000.0 // steps/sec
#define STEPS_PER_REV 200    // 1.8¬∞ stepper = 200 steps/rev
#define MICROSTEPS 16        // DRV8825 microstepping

// ==================== SERVO PINS (4 storage compartments) ====================
// Servos for storage door control
// PWM frequency: 50Hz (20ms period)
// Pulse width: 1ms (0¬∞) to 2ms (180¬∞)

#define SERVO_SLOT_0 17 // GPIO17 - Safe (U2TXD but can reuse)
#define SERVO_SLOT_1 5  // GPIO5 - Safe after boot
#define SERVO_SLOT_2 18 // GPIO18 - Safe (VSPI CLK but can reuse)
#define SERVO_SLOT_3 19 // GPIO19 - Safe (VSPI MISO but can reuse)

// ==================== LED INDICATOR PINS (4 LEDs) ====================
// LED indicators for storage compartments
// D√πng GPIO c√≤n tr·ªëng

#define LED_SLOT_0 2  // GPIO2 - Safe sau boot (onboard LED)
#define LED_SLOT_1 0  // GPIO0 - Safe sau boot (boot button LED)
#define LED_SLOT_2 12 // GPIO12 - TR√ÅNH n·∫øu c√≥ th·ªÉ (flash voltage)
#define LED_SLOT_3 15 // GPIO15 - Safe v·ªõi pull-up resistor

// ‚ö†Ô∏è CH√ö √ù GPIO15: C·∫ßn pull-up 10kŒ© ƒë·ªÉ boot ƒë√∫ng (must be HIGH at boot)

// ==================== STATUS LED PINS ====================
#define LED_STATUS 2       // GPIO2 - Onboard LED (blue)
#define LED_I2C_ACTIVITY 0 // GPIO0 - Boot button LED

// ==================== SERVO CONFIGURATION ====================
// Servo angle limits
#define SERVO_ANGLE_OPEN 0   // 0¬∞ = door open
#define SERVO_ANGLE_CLOSE 90 // 90¬∞ = door closed
#define SERVO_MIN_US 500     // Minimum pulse width (¬µs)
#define SERVO_MAX_US 2500    // Maximum pulse width (¬µs)

// ==================== GLOBAL VARIABLES ====================
String rxBuffer = "";       // Buffer for incoming I2C data
bool commandReady = false;  // Flag when complete command received
String responseBuffer = ""; // Response to send back

// Serial testing variables
String serialBuffer = "";        // Buffer for incoming Serial data
bool serialCommandReady = false; // Flag when complete Serial command received

// AccelStepper objects for 4 motors (Mecanum wheels)
// Constructor: AccelStepper(DRIVER, stepPin, dirPin)
AccelStepper motorFL(AccelStepper::DRIVER, MOTOR_FL_STEP,
                     MOTOR_FL_DIR); // Front Left
AccelStepper motorFR(AccelStepper::DRIVER, MOTOR_FR_STEP,
                     MOTOR_FR_DIR); // Front Right
AccelStepper motorBL(AccelStepper::DRIVER, MOTOR_BL_STEP,
                     MOTOR_BL_DIR); // Back Left
AccelStepper motorBR(AccelStepper::DRIVER, MOTOR_BR_STEP,
                     MOTOR_BR_DIR); // Back Right

// ESP32Servo objects for 4 servos
Servo servos[4];

// Storage LED states
bool storageLEDs[4] = {false, false, false, false};

// Movement state
unsigned long movementStartTime = 0;
int movementDuration = 0;
bool isMoving = false;

// ==================== STEPPER MOTOR CONTROL (AccelStepper)
// ====================
/**
 * Mecanum wheel movement equations:
 *
 * Forward:     FL=+, FR=+, BL=+, BR=+
 * Backward:    FL=-, FR=-, BL=-, BR=-
 * Left:        FL=-, FR=+, BL=+, BR=-
 * Right:       FL=+, FR=-, BL=-, BR=+
 * Rotate Left: FL=-, FR=+, BL=-, BR=+
 * Rotate Right:FL=+, FR=-, BL=+, BR=-
 */

// ==================== STEPPER MOTOR CONTROL ====================
void setupMotors() {
  // Setup enable pin (common for all motors)
  pinMode(MOTOR_EN, OUTPUT);
  digitalWrite(MOTOR_EN, HIGH); // HIGH = disabled (active LOW on most drivers)

  // Configure AccelStepper motors
  motorFL.setMaxSpeed(MAX_SPEED);
  motorFL.setAcceleration(ACCELERATION);

  motorFR.setMaxSpeed(MAX_SPEED);
  motorFR.setAcceleration(ACCELERATION);

  motorBL.setMaxSpeed(MAX_SPEED);
  motorBL.setAcceleration(ACCELERATION);

  motorBR.setMaxSpeed(MAX_SPEED);
  motorBR.setAcceleration(ACCELERATION);

  Serial.println("‚úÖ Stepper motors initialized (ESP32 DevKit)");
  Serial.printf("   Motor EN: GPIO%d (Active LOW)\n", MOTOR_EN);
  Serial.printf("   FL: STEP=GPIO%d, DIR=GPIO%d\n", MOTOR_FL_STEP,
                MOTOR_FL_DIR);
  Serial.printf("   FR: STEP=GPIO%d, DIR=GPIO%d\n", MOTOR_FR_STEP,
                MOTOR_FR_DIR);
  Serial.printf("   BL: STEP=GPIO%d, DIR=GPIO%d\n", MOTOR_BL_STEP,
                MOTOR_BL_DIR);
  Serial.printf("   BR: STEP=GPIO%d, DIR=GPIO%d\n", MOTOR_BR_STEP,
                MOTOR_BR_DIR);
  Serial.printf("   Max Speed: %.0f steps/sec\n", MAX_SPEED);
  Serial.printf("   Acceleration: %.0f steps/sec¬≤\n", ACCELERATION);
}

void enableMotors() {
  digitalWrite(MOTOR_EN, LOW); // Active LOW
  Serial.println("‚úÖ Motors ENABLED");
}

void disableMotors() {
  digitalWrite(MOTOR_EN, HIGH); // Active LOW
  Serial.println("‚è∏Ô∏è  Motors DISABLED");
}

void setMotorSpeed(float speedPercent) {
  // speedPercent: 0-100
  float actualSpeed = map(speedPercent, 0, 100, 0, MAX_SPEED);
  actualSpeed = constrain(actualSpeed, 0, MAX_SPEED);

  motorFL.setSpeed(actualSpeed);
  motorFR.setSpeed(actualSpeed);
  motorBL.setSpeed(actualSpeed);
  motorBR.setSpeed(actualSpeed);
}

void moveVehicle(String direction, int speed, int duration_ms) {
  Serial.printf("üöó Moving: %s, speed=%d, duration=%dms\n", direction.c_str(),
                speed, duration_ms);

  enableMotors();

  // Calculate speed for each motor
  float motorSpeed = map(speed, 0, 100, 0, MAX_SPEED);
  motorSpeed = constrain(motorSpeed, 0, MAX_SPEED);

  // Set movement direction and speeds based on Mecanum equations
  if (direction == "forward") {
    motorFL.setSpeed(motorSpeed); // +
    motorFR.setSpeed(motorSpeed); // +
    motorBL.setSpeed(motorSpeed); // +
    motorBR.setSpeed(motorSpeed); // +
  } else if (direction == "backward") {
    motorFL.setSpeed(-motorSpeed); // -
    motorFR.setSpeed(-motorSpeed); // -
    motorBL.setSpeed(-motorSpeed); // -
    motorBR.setSpeed(-motorSpeed); // -
  } else if (direction == "left") {
    motorFL.setSpeed(-motorSpeed); // -
    motorFR.setSpeed(motorSpeed);  // +
    motorBL.setSpeed(motorSpeed);  // +
    motorBR.setSpeed(-motorSpeed); // -
  } else if (direction == "right") {
    motorFL.setSpeed(motorSpeed);  // +
    motorFR.setSpeed(-motorSpeed); // -
    motorBL.setSpeed(-motorSpeed); // -
    motorBR.setSpeed(motorSpeed);  // +
  } else if (direction == "rotate_left") {
    motorFL.setSpeed(-motorSpeed); // -
    motorFR.setSpeed(motorSpeed);  // +
    motorBL.setSpeed(-motorSpeed); // -
    motorBR.setSpeed(motorSpeed);  // +
  } else if (direction == "rotate_right") {
    motorFL.setSpeed(motorSpeed);  // +
    motorFR.setSpeed(-motorSpeed); // -
    motorBL.setSpeed(motorSpeed);  // +
    motorBR.setSpeed(-motorSpeed); // -
  } else if (direction == "stop") {
    stopAllMotors();
    return;
  }

  // Set movement state
  isMoving = true;
  movementStartTime = millis();
  movementDuration = duration_ms;

  Serial.printf("‚úÖ Movement started at speed=%.0f steps/sec\n", motorSpeed);
}

void stopAllMotors() {
  motorFL.setSpeed(0);
  motorFL.stop();

  motorFR.setSpeed(0);
  motorFR.stop();

  motorBL.setSpeed(0);
  motorBL.stop();

  motorBR.setSpeed(0);
  motorBR.stop();

  disableMotors();
  isMoving = false;

  Serial.println("üõë All motors stopped");
}

void updateMotors() {
  // Check if movement duration exceeded
  if (isMoving && movementDuration > 0) {
    if (millis() - movementStartTime >= movementDuration) {
      stopAllMotors();
      return;
    }
  }

  // Run motors if moving
  if (isMoving) {
    motorFL.runSpeed();
    motorFR.runSpeed();
    motorBL.runSpeed();
    motorBR.runSpeed();
  }
}

// ==================== STORAGE DOOR CONTROL ====================
void setupServos() {
  // Initialize ESP32Servo library
  // ESP32 has 16 PWM channels, we use 4 for servos

  // Attach servos to pins
  servos[0].attach(SERVO_SLOT_0, SERVO_MIN_US, SERVO_MAX_US);
  servos[1].attach(SERVO_SLOT_1, SERVO_MIN_US, SERVO_MAX_US);
  servos[2].attach(SERVO_SLOT_2, SERVO_MIN_US, SERVO_MAX_US);
  servos[3].attach(SERVO_SLOT_3, SERVO_MIN_US, SERVO_MAX_US);

  // Close all doors initially (90 degrees = closed)
  for (int i = 0; i < 4; i++) {
    servos[i].write(SERVO_ANGLE_CLOSE);
    delay(100); // Small delay between servo movements
  }

  Serial.println("‚úÖ Servos initialized (4 storage slots)");
  Serial.printf("   Slot 0: GPIO%d\n", SERVO_SLOT_0);
  Serial.printf("   Slot 1: GPIO%d\n", SERVO_SLOT_1);
  Serial.printf("   Slot 2: GPIO%d\n", SERVO_SLOT_2);
  Serial.printf("   Slot 3: GPIO%d\n", SERVO_SLOT_3);
  Serial.printf("   Pulse range: %d-%d ¬µs\n", SERVO_MIN_US, SERVO_MAX_US);
}

void setupLEDs() {
  // Setup LED pins
  pinMode(LED_SLOT_0, OUTPUT); // GPIO2
  pinMode(LED_SLOT_1, OUTPUT); // GPIO0
  pinMode(LED_SLOT_2, OUTPUT); // GPIO12 (‚ö†Ô∏è strapping pin)
  pinMode(LED_SLOT_3, OUTPUT); // GPIO15 (‚ö†Ô∏è needs pull-up)

  pinMode(LED_STATUS, OUTPUT);
  pinMode(LED_I2C_ACTIVITY, OUTPUT);

  // Turn off all LEDs
  digitalWrite(LED_SLOT_0, LOW);
  digitalWrite(LED_SLOT_1, LOW);
  digitalWrite(LED_SLOT_2, LOW);
  digitalWrite(LED_SLOT_3, LOW);
  digitalWrite(LED_STATUS, LOW);
  digitalWrite(LED_I2C_ACTIVITY, LOW);

  Serial.println("‚úÖ LEDs initialized");
  Serial.printf("   Slot 0: GPIO%d\n", LED_SLOT_0);
  Serial.printf("   Slot 1: GPIO%d\n", LED_SLOT_1);
  Serial.printf("   Slot 2: GPIO%d (‚ö†Ô∏è strapping pin)\n", LED_SLOT_2);
  Serial.printf("   Slot 3: GPIO%d (‚ö†Ô∏è needs pull-up)\n", LED_SLOT_3);
  Serial.println("   Status: GPIO2 (onboard LED)");
}

void controlStorageDoor(int slot, String action) {
  Serial.printf("üö™ Storage door: slot=%d, action=%s\n", slot, action.c_str());

  if (slot < 0 || slot > 3) {
    Serial.println("‚ùå Invalid slot");
    return;
  }

  int angle = SERVO_ANGLE_CLOSE; // Default closed

  if (action == "open") {
    angle = SERVO_ANGLE_OPEN; // 0 degrees = open
    storageLEDs[slot] = true;
  } else if (action == "close") {
    angle = SERVO_ANGLE_CLOSE; // 90 degrees = closed
    storageLEDs[slot] = false;
  } else if (action == "led_on") {
    storageLEDs[slot] = true;
    updateStorageLED(slot);
    return;
  } else if (action == "led_off") {
    storageLEDs[slot] = false;
    updateStorageLED(slot);
    return;
  } else if (action == "led_blink") {
    // Blink LED 3 times
    for (int i = 0; i < 3; i++) {
      storageLEDs[slot] = true;
      updateStorageLED(slot);
      delay(200);
      storageLEDs[slot] = false;
      updateStorageLED(slot);
      delay(200);
    }
    return;
  }

  // Move servo to angle using ESP32Servo library
  servos[slot].write(angle);

  // Update LED
  updateStorageLED(slot);

  Serial.printf("‚úÖ Slot %d door %s (angle=%d¬∞)\n", slot, action.c_str(),
                angle);
}

void updateStorageLED(int slot) {
  // Update LED state for storage slot
  bool state = storageLEDs[slot];

  switch (slot) {
  case 0:
    digitalWrite(LED_SLOT_0, state ? HIGH : LOW);
    break;
  case 1:
    digitalWrite(LED_SLOT_1, state ? HIGH : LOW);
    break;
  case 2:
    digitalWrite(LED_SLOT_2, state ? HIGH : LOW);
    break;
  case 3:
    digitalWrite(LED_SLOT_3, state ? HIGH : LOW);
    break;
  }
}

// ==================== SERIAL TESTING ====================
void processSerialInput() {
  while (Serial.available()) {
    char c = Serial.read();

    if (c == '\n' || c == '\r') {
      if (serialBuffer.length() > 0) {
        // Ch·ªâ x·ª≠ l√Ω n·∫øu buffer ch·ª©a k√Ω t·ª± ASCII h·ª£p l·ªá
        bool isValid = true;
        for (int i = 0; i < serialBuffer.length(); i++) {
          char ch = serialBuffer.charAt(i);
          // Ch·ªâ ch·∫•p nh·∫≠n: ch·ªØ c√°i, s·ªë, JSON characters, space, underscore
          if (!isalnum(ch) && ch != '{' && ch != '}' && ch != '"' &&
              ch != ':' && ch != ',' && ch != '_' && ch != ' ' && ch != '.' &&
              ch != '-') {
            isValid = false;
            break;
          }
        }

        if (isValid) {
          serialCommandReady = true;
        } else {
          // B·ªè qua d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá
          serialBuffer = "";
        }
        break;
      }
    } else if (c >= 32 && c <= 126) {
      // Ch·ªâ nh·∫≠n k√Ω t·ª± ASCII printable (32-126)
      serialBuffer += c;
    }
    // B·ªè qua c√°c k√Ω t·ª± control characters v√† k√Ω t·ª± r√°c
  }
}

void printTestMenu() {
  Serial.println("\n==================== TEST MENU ====================");
  Serial.println("Vehicle Movement Tests:");
  Serial.println("  1. forward     - Move forward for 2 seconds");
  Serial.println("  2. backward    - Move backward for 2 seconds");
  Serial.println("  3. left        - Move left for 2 seconds");
  Serial.println("  4. right       - Move right for 2 seconds");
  Serial.println("  5. rotate_left - Rotate left for 2 seconds");
  Serial.println("  6. rotate_right- Rotate right for 2 seconds");
  Serial.println("  7. stop        - Stop all motors");
  Serial.println();
  Serial.println("Storage Tests:");
  Serial.println("  o0 - Open slot 0    | c0 - Close slot 0");
  Serial.println("  o1 - Open slot 1    | c1 - Close slot 1");
  Serial.println("  o2 - Open slot 2    | c2 - Close slot 2");
  Serial.println("  o3 - Open slot 3    | c3 - Close slot 3");
  Serial.println();
  Serial.println("LED Tests:");
  Serial.println("  lon0 - LED slot 0 ON   | loff0 - LED slot 0 OFF");
  Serial.println("  lon1 - LED slot 1 ON   | loff1 - LED slot 1 OFF");
  Serial.println("  blink0 - Blink slot 0  | blink1 - Blink slot 1");
  Serial.println();
  Serial.println("JSON Tests:");
  Serial.println("  json1 - Vehicle move forward JSON test");
  Serial.println("  json2 - Storage control JSON test");
  Serial.println("  json3 - Status request JSON test");
  Serial.println();
  Serial.println("Other:");
  Serial.println("  status - Get system status");
  Serial.println("  help   - Show this menu");
  Serial.println("===================================================");
}

void executeTestCommand(String cmd) {
  cmd.trim();

  // B·ªè qua n·∫øu command r·ªóng
  if (cmd.length() == 0) {
    return;
  }

  cmd.toLowerCase();

  Serial.printf("üß™ Executing test command: '%s'\n", cmd.c_str());

  // Vehicle movement tests
  if (cmd == "1" || cmd == "forward") {
    moveVehicle("forward", 50, 2000);
  } else if (cmd == "2" || cmd == "backward") {
    moveVehicle("backward", 50, 2000);
  } else if (cmd == "3" || cmd == "left") {
    moveVehicle("left", 50, 2000);
  } else if (cmd == "4" || cmd == "right") {
    moveVehicle("right", 50, 2000);
  } else if (cmd == "5" || cmd == "rotate_left") {
    moveVehicle("rotate_left", 50, 2000);
  } else if (cmd == "6" || cmd == "rotate_right") {
    moveVehicle("rotate_right", 50, 2000);
  } else if (cmd == "7" || cmd == "stop") {
    moveVehicle("stop", 0, 0);
  }

  // Storage door tests
  else if (cmd.startsWith("o") && cmd.length() == 2) {
    int slot = cmd.charAt(1) - '0';
    if (slot >= 0 && slot <= 5) {
      controlStorageDoor(slot, "open");
    }
  } else if (cmd.startsWith("c") && cmd.length() == 2) {
    int slot = cmd.charAt(1) - '0';
    if (slot >= 0 && slot <= 5) {
      controlStorageDoor(slot, "close");
    }
  }

  // LED tests
  else if (cmd.startsWith("lon") && cmd.length() == 4) {
    int slot = cmd.charAt(3) - '0';
    if (slot >= 0 && slot <= 5) {
      controlStorageDoor(slot, "led_on");
    }
  } else if (cmd.startsWith("loff") && cmd.length() == 5) {
    int slot = cmd.charAt(4) - '0';
    if (slot >= 0 && slot <= 5) {
      controlStorageDoor(slot, "led_off");
    }
  } else if (cmd.startsWith("blink") && cmd.length() == 6) {
    int slot = cmd.charAt(5) - '0';
    if (slot >= 0 && slot <= 5) {
      controlStorageDoor(slot, "led_blink");
    }
  }

  // JSON tests
  else if (cmd == "json1") {
    Serial.println("üìã Testing JSON vehicle command:");
    String testJson = "{\"type\":\"vehicle.move\",\"direction\":\"forward\","
                      "\"speed\":75,\"duration_ms\":3000}";
    Serial.println("   " + testJson);
    processCommand(testJson);
    Serial.println("   Response: " + responseBuffer);
    responseBuffer = "";
  } else if (cmd == "json2") {
    Serial.println("üìã Testing JSON storage command:");
    String testJson =
        "{\"type\":\"storage.control\",\"slot\":1,\"action\":\"open\"}";
    Serial.println("   " + testJson);
    processCommand(testJson);
    Serial.println("   Response: " + responseBuffer);
    responseBuffer = "";
  } else if (cmd == "json3") {
    Serial.println("üìã Testing JSON status request:");
    String testJson = "{\"type\":\"status.get\"}";
    Serial.println("   " + testJson);
    processCommand(testJson);
    Serial.println("   Response: " + responseBuffer);
    responseBuffer = "";
  }

  // Status and help
  else if (cmd == "status") {
    Serial.println("\n========== SYSTEM STATUS ==========");
    Serial.printf("Motors Enabled: %s\n",
                  digitalRead(MOTOR_EN) == LOW ? "YES" : "NO");
    Serial.printf("Is Moving: %s\n", isMoving ? "YES" : "NO");
    if (isMoving) {
      Serial.printf("Movement Duration: %d ms\n", movementDuration);
      Serial.printf("Time Elapsed: %lu ms\n", millis() - movementStartTime);
    }
    Serial.println("Storage LEDs:");
    for (int i = 0; i < 6; i++) {
      Serial.printf("  Slot %d: %s\n", i, storageLEDs[i] ? "ON" : "OFF");
    }
    Serial.println("===================================");
  } else if (cmd == "help") {
    printTestMenu();
  }

  // Handle JSON input directly
  else if (cmd.startsWith("{") && cmd.endsWith("}")) {
    Serial.println("üìã Processing direct JSON command:");
    Serial.println("   " + cmd);
    processCommand(cmd);
    Serial.println("   Response: " + responseBuffer);
    responseBuffer = "";
  }

  else {
    Serial.println("‚ùå Unknown command. Type 'help' for available commands.");
  }
}
void onI2CReceive(int numBytes) {
  digitalWrite(LED_I2C_ACTIVITY, HIGH);

  // ========== STRICT VALIDATION: Ch·ªâ nh·∫≠n data h·ª£p l·ªá ==========

  // B·ªè qua n·∫øu nh·∫≠n qu√° √≠t bytes (noise)
  if (numBytes < 10) {
    // Flush buffer ƒë·ªÉ clear noise
    while (Wire.available()) {
      Wire.read();
    }
    digitalWrite(LED_I2C_ACTIVITY, LOW);
    return; // Silent ignore - kh√¥ng log ƒë·ªÉ tr√°nh spam
  }

  // ƒê·ªçc t·∫•t c·∫£ bytes c√≥ s·∫µn
  String tempBuffer = "";
  int bytesRead = 0;
  bool hasOpenBrace = false;

  while (Wire.available() && bytesRead < 256) { // Max 256 bytes
    char c = Wire.read();
    bytesRead++;

    // Check first char
    if (bytesRead == 1) {
      if (c != '{') {
        // Not JSON - clear rest and ignore
        while (Wire.available())
          Wire.read();
        digitalWrite(LED_I2C_ACTIVITY, LOW);
        return; // Silent ignore
      }
      hasOpenBrace = true;
    }

    tempBuffer += c;

    // K·∫øt th√∫c khi g·∫∑p d·∫•u ƒë√≥ng ngo·∫∑c JSON
    if (c == '}') {
      break;
    }
  }

  // Validate: Ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng '{' v√† k·∫øt th√∫c b·∫±ng '}'
  if (hasOpenBrace && tempBuffer.length() >= 10 &&
      tempBuffer.charAt(0) == '{' && tempBuffer.endsWith("}")) {

    // Extra validation: Check if it contains "type" field (required)
    if (tempBuffer.indexOf("\"type\"") > 0) {
      rxBuffer = tempBuffer;
      commandReady = true;
      Serial.printf("üì© Received %d bytes: %s\n", bytesRead, rxBuffer.c_str());
    } else {
      // Invalid JSON - missing "type" field
      Serial.printf("‚ö†Ô∏è  Rejected incomplete JSON (%d bytes): %s\n", bytesRead,
                    tempBuffer.c_str());
    }
  } else {
    // Invalid format - log v·ªõi hex dump ƒë·ªÉ debug
    Serial.printf("‚ö†Ô∏è  Rejected invalid I2C data (%d bytes)\n", bytesRead);
    Serial.print("   Hex: ");
    for (unsigned int i = 0; i < min(tempBuffer.length(), 20u); i++) {
      Serial.printf("%02X ", (uint8_t)tempBuffer.charAt(i));
    }
    Serial.println();
  }

  digitalWrite(LED_I2C_ACTIVITY, LOW);
}

void onI2CRequest() {
  digitalWrite(LED_I2C_ACTIVITY, HIGH);

  if (responseBuffer.length() > 0) {
    Wire.write(responseBuffer.c_str());
    Serial.printf("üì§ Sent response: %s\n", responseBuffer.c_str());
    responseBuffer = ""; // Clear after sending
  } else {
    Wire.write("{\"status\":\"ok\"}");
  }

  digitalWrite(LED_I2C_ACTIVITY, LOW);
}

void processCommand(String jsonStr) {
  StaticJsonDocument<512> doc;
  DeserializationError error = deserializeJson(doc, jsonStr);

  if (error) {
    Serial.printf("‚ùå JSON parse error: %s\n", error.c_str());
    responseBuffer = "{\"status\":\"error\",\"message\":\"Invalid JSON\"}";
    return;
  }

  String cmdType = doc["type"].as<String>();
  Serial.printf("üîß Processing command: %s\n", cmdType.c_str());

  if (cmdType == "vehicle.move") {
    String direction = doc["direction"].as<String>();
    int speed = doc["speed"] | 50;
    int duration = doc["duration_ms"] | 0;

    moveVehicle(direction, speed, duration);
    responseBuffer = "{\"status\":\"ok\",\"message\":\"Vehicle moving\"}";
  } else if (cmdType == "storage.control") {
    int slot = doc["slot"] | -1;
    String action = doc["action"].as<String>();

    controlStorageDoor(slot, action);
    responseBuffer = "{\"status\":\"ok\",\"message\":\"Storage controlled\"}";
  } else if (cmdType == "status.get") {
    // Build status JSON
    StaticJsonDocument<256> statusDoc;
    statusDoc["battery"] = 12.5; // Dummy value
    statusDoc["motors_enabled"] = !digitalRead(MOTOR_EN);
    statusDoc["is_moving"] = isMoving;

    serializeJson(statusDoc, responseBuffer);
  } else {
    responseBuffer = "{\"status\":\"error\",\"message\":\"Unknown command\"}";
  }
}

void TaskRestart(void *pvParameters) {

  while (1) {
    // setup_bluetooth();
    // hrBle.loop();
    bluetooth_init();
    vTaskDelete(NULL);
    // vTaskDelay(1 / portTICK_PERIOD_MS);
  }
}

// ==================== SETUP & LOOP ====================
void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n\n========================================");
  Serial.println("  ü§ñ Xiaozhi Actuator - ESP32 DevKit  ");
  Serial.println("     Mecanum Robot Control System     ");
  Serial.println("========================================\n");

  Serial.println("üìã Hardware Configuration:");
  Serial.println("   Board: ESP32 DevKit v1 (30-pin)");
  Serial.println("   CPU: ESP32-WROOM-32");
  Serial.printf("   Firmware: v1.0.0\n");
  Serial.printf("   Build: %s %s\n", __DATE__, __TIME__);
  Serial.println();

  // Initialize components
  Serial.println("‚öôÔ∏è  Initializing components...\n");

  setupLEDs();
  digitalWrite(LED_STATUS, HIGH);
  Serial.println();

  setupMotors();
  Serial.println();

  setupServos();
  Serial.println();

  xTaskCreatePinnedToCore(TaskRestart, "TaskRestart", 15000, NULL, 1, NULL, 1);

  // Initialize I2C Slave
  Wire.begin(I2C_SLAVE_ADDR, I2C_SDA_PIN, I2C_SCL_PIN, 100000);
  Wire.onReceive(onI2CReceive);
  Wire.onRequest(onI2CRequest);

  Serial.printf("‚úÖ I2C Slave initialized at address 0x%02X\n", I2C_SLAVE_ADDR);
  Serial.printf("   SDA: GPIO%d, SCL: GPIO%d, Frequency: 100kHz\n", I2C_SDA_PIN,
                I2C_SCL_PIN);
  Serial.println();

  Serial.println("‚ö†Ô∏è  GPIO Warnings:");
  Serial.println("   - GPIO15 (LED_3): Add 10kŒ© pull-up resistor");
  Serial.println("   - GPIO12 (LED_2): Strapping pin, may affect boot");
  Serial.println();

  Serial.println("üéØ System ready to receive commands!");
  Serial.println("   Type 'help' for test menu\n");

  // Print test menu
  printTestMenu();

  // Blink LED to indicate ready
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED_STATUS, LOW);
    delay(150);
    digitalWrite(LED_STATUS, HIGH);
    delay(150);
  }

  Serial.println("‚úÖ Initialization complete!\n");
  Serial.println("==========================================\n");
}

void loop() {
  // Update motors (must be called frequently for AccelStepper)
  updateMotors();

  // Process Serial input for testing
  processSerialInput();

  // Process Serial command if received
  if (serialCommandReady) {
    executeTestCommand(serialBuffer);
    serialBuffer = "";
    serialCommandReady = false;
  }

  // Process I2C command if received
  if (commandReady) {
    Serial.printf("üîÑ Processing I2C buffer: %s\n", rxBuffer.c_str());
    processCommand(rxBuffer);
    rxBuffer = "";
    commandReady = false;
  }

  // Heartbeat LED (slower blink to avoid conflict with I2C activity)
  static unsigned long lastBlink = 0;
  if (millis() - lastBlink > 2000) {
    digitalWrite(LED_STATUS, !digitalRead(LED_STATUS));
    lastBlink = millis();
  }

  delay(1); // Small delay for stability
}
