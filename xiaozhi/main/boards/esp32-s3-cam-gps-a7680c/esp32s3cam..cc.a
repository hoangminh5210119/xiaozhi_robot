#include "application.h"
#include "assets/lang_config.h"
#include "button.h"
#include "codecs/no_audio_codec.h"
#include "adc_i2s_audio_codec.h"
#include "config.h"
#include "display/oled_display.h"
#include "dual_network_board.h"
#include "esp32_camera.h"
#include "lamp_controller.h"
#include "led/single_led.h"
#include "mcp_server.h"
#include "nmea_parser.h"
#include "system_reset.h"
#include "wifi_board.h"
#include <driver/i2c_master.h>
#include <esp_lcd_panel_ops.h>
#include <esp_lcd_panel_vendor.h>
#include <esp_log.h>
#include <esp_spiffs.h>

#include "esp_http_client.h"
#include "esp_log.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// #include <wifi_station.h>
#include "telegram_manager.h" // Add this include

#include "RecurringSchedule.h"
#include "StorageManager.h"

#define TAG "esp32-s3-cam-gps-a7680c"

class Esp32S3CamGpsA7680cBoard : public DualNetworkBoard {
private:
  i2c_master_bus_handle_t display_i2c_bus_;
  esp_lcd_panel_io_handle_t panel_io_ = nullptr;
  esp_lcd_panel_handle_t panel_ = nullptr;
  Display *display_ = nullptr;
  Button capture_button_;
  Button mode_button_;
  Button send_button_;

  Esp32Camera *camera_;

  // RecurringSchedule *scheduler_;

  void MountStorage() {
    // Mount partition "storage" ri√™ng cho l∆∞u tr·ªØ d·ªØ li·ªáu ng∆∞·ªùi d√πng
    esp_vfs_spiffs_conf_t storage_conf = {
        .base_path = "/storage",
        .partition_label = "storage",
        .max_files = 5,
        .format_if_mount_failed = true,  // C√≥ th·ªÉ format n·∫øu c·∫ßn
    };
    esp_err_t ret = esp_vfs_spiffs_register(&storage_conf);
    if (ret != ESP_OK) {
      ESP_LOGE(TAG, "Failed to mount storage partition (%s)", esp_err_to_name(ret));
    } else {
      ESP_LOGI(TAG, "Storage partition mounted at /storage");
    }
  }

  void InitializeDisplayI2c() {
    i2c_master_bus_config_t bus_config = {
        .i2c_port = (i2c_port_t)0,
        .sda_io_num = DISPLAY_SDA_PIN,
        .scl_io_num = DISPLAY_SCL_PIN,
        .clk_source = I2C_CLK_SRC_DEFAULT,
        .glitch_ignore_cnt = 7,
        .intr_priority = 0,
        .trans_queue_depth = 0,
        .flags =
            {
                .enable_internal_pullup = 1,
            },
    };
    ESP_ERROR_CHECK(i2c_new_master_bus(&bus_config, &display_i2c_bus_));
  }

  void InitializeCamera() {
    camera_config_t config = {};
    config.pin_d0 = CAMERA_PIN_D0;
    config.pin_d1 = CAMERA_PIN_D1;
    config.pin_d2 = CAMERA_PIN_D2;
    config.pin_d3 = CAMERA_PIN_D3;
    config.pin_d4 = CAMERA_PIN_D4;
    config.pin_d5 = CAMERA_PIN_D5;
    config.pin_d6 = CAMERA_PIN_D6;
    config.pin_d7 = CAMERA_PIN_D7;
    config.pin_xclk = CAMERA_PIN_XCLK;
    config.pin_pclk = CAMERA_PIN_PCLK;
    config.pin_vsync = CAMERA_PIN_VSYNC;
    config.pin_href = CAMERA_PIN_HREF;
    config.pin_sccb_sda = CAMERA_PIN_SIOD;
    config.pin_sccb_scl = CAMERA_PIN_SIOC;
    config.sccb_i2c_port = 0;
    config.pin_pwdn = CAMERA_PIN_PWDN;
    config.pin_reset = CAMERA_PIN_RESET;
    config.xclk_freq_hz = XCLK_FREQ_HZ;
    config.pixel_format = PIXFORMAT_RGB565;
    config.frame_size = FRAMESIZE_QVGA;
    config.jpeg_quality = 12;
    config.fb_count = 1;
    config.fb_location = CAMERA_FB_IN_PSRAM;
    config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;
    camera_ = new Esp32Camera(config);
    camera_->SetHMirror(false);
    camera_->SetVFlip(true);
  }

  void InitializeSsd1306Display() {
    // SSD1306 config
    esp_lcd_panel_io_i2c_config_t io_config = {
        .dev_addr = 0x3C,
        .on_color_trans_done = nullptr,
        .user_ctx = nullptr,
        .control_phase_bytes = 1,
        .dc_bit_offset = 6,
        .lcd_cmd_bits = 8,
        .lcd_param_bits = 8,
        .flags =
            {
                .dc_low_on_data = 0,
                .disable_control_phase = 0,
            },
        .scl_speed_hz = 400 * 1000,
    };

    ESP_ERROR_CHECK(
        esp_lcd_new_panel_io_i2c_v2(display_i2c_bus_, &io_config, &panel_io_));

    ESP_LOGI(TAG, "Install SSD1306 driver");
    esp_lcd_panel_dev_config_t panel_config = {};
    panel_config.reset_gpio_num = -1;
    panel_config.bits_per_pixel = 1;

    esp_lcd_panel_ssd1306_config_t ssd1306_config = {
        .height = static_cast<uint8_t>(DISPLAY_HEIGHT),
    };
    panel_config.vendor_config = &ssd1306_config;

    ESP_ERROR_CHECK(
        esp_lcd_new_panel_ssd1306(panel_io_, &panel_config, &panel_));
    ESP_LOGI(TAG, "SSD1306 driver installed");

    // Reset the display
    ESP_ERROR_CHECK(esp_lcd_panel_reset(panel_));
    if (esp_lcd_panel_init(panel_) != ESP_OK) {
      ESP_LOGE(TAG, "Failed to initialize display");
      display_ = new NoDisplay();
      return;
    }

    // Set the display to on
    ESP_LOGI(TAG, "Turning display on");
    ESP_ERROR_CHECK(esp_lcd_panel_disp_on_off(panel_, true));

    display_ = new OledDisplay(panel_io_, panel_, DISPLAY_WIDTH, DISPLAY_HEIGHT,
                               DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
  }

  void fetch_reverse_geocode(double lat, double lon) {
    char url[256];
    snprintf(
        url, sizeof(url),
        "https://nominatim.openstreetmap.org/reverse?format=json&lat=%f&lon=%f",
        lat, lon);

    esp_http_client_config_t config = {};
    config.url = url;
    config.cert_pem = NULL;
    config.method = HTTP_METHOD_GET;
    config.disable_auto_redirect = false;
    config.user_agent = "ESP32GeoApp/1.0 (contact: your_email@example.com)";

    esp_http_client_handle_t client = esp_http_client_init(&config);
    if (client == NULL) {
      ESP_LOGE(TAG, "Failed to init http client");
      return;
    }

    esp_err_t err = esp_http_client_perform(client);
    if (err == ESP_OK) {
      int status = esp_http_client_get_status_code(client);
      int content_length = esp_http_client_get_content_length(client);
      ESP_LOGI(TAG, "HTTP GET Status = %d, content_length = %d", status,
               content_length);

      char buffer[1024];
      int read_len =
          esp_http_client_read_response(client, buffer, sizeof(buffer) - 1);
      if (read_len >= 0) {
        buffer[read_len] = 0; // null terminate
        ESP_LOGI(TAG, "Response: %s", buffer);

        // parse JSON (v√≠ d·ª• l·∫•y ƒë·ªãa ch·ªâ display_name)
        cJSON *root = cJSON_Parse(buffer);
        if (root) {
          cJSON *display = cJSON_GetObjectItem(root, "display_name");
          if (cJSON_IsString(display)) {
            ESP_LOGI(TAG, "Location: %s", display->valuestring);
          }
          cJSON_Delete(root);
        }
      } else {
        ESP_LOGE(TAG, "Failed to read response");
      }
    } else {
      ESP_LOGE(TAG, "HTTP GET request failed: %s", esp_err_to_name(err));
    }

    esp_http_client_cleanup(client);
  }

  void InitializeButtons() {
    capture_button_.OnClick([this]() {
      ESP_LOGI(TAG, "Capture button clicked - Switching network type (4G <-> WiFi)");
      auto &app = Application::GetInstance();
      // Chuy·ªÉn ƒë·ªïi gi·ªØa 4G v√† WiFi
      app.Schedule([this]() {
        SwitchNetworkType();
        ESP_LOGI(TAG, "Network type switched successfully");
      });
    });

    mode_button_.OnClick([this]() {
      ESP_LOGI(TAG, "Mode button clicked - toggle chat state");
      auto &app = Application::GetInstance();
      app.Schedule([this]() {
        auto &app = Application::GetInstance();
        app.SendTextCommandToServer("h·ªßy b·ªè l·ªãch 1");
        auto scheduler_ = &RecurringSchedule::GetInstance();
        scheduler_->removeSchedule(1);
      });
    });

    send_button_.OnClick([this]() {
      ESP_LOGI(TAG, "Send button clicked - toggle chat state");

      auto &app = Application::GetInstance();
      app.Schedule([this]() {
        auto &app = Application::GetInstance();
        app.ToggleChatState();
      });

      // toggle chat state
    });
  }

  void InitializeTools() {
    static LampController lamp(SOS_LED_PIN);
    auto &mcp = McpServer::GetInstance();
    auto &app = Application::GetInstance();
    auto &telegram = TelegramManager::GetInstance();
    auto &storage = StorageManager::GetInstance();
    auto &scheduler = RecurringSchedule::GetInstance();

    // Kh·ªüi t·∫°o RecurringSchedule v·ªõi file path gi·ªëng StorageManager
    scheduler.begin("/storage/schedule.json");
    scheduler.setCallback([&app](int id, const std::string &note) {
      ESP_LOGI(TAG, "‚è∞ Schedule triggered: id=%d, note=%s", id, note.c_str());
      app.SendTextCommandToServer(note);
    });

    // Kh·ªüi t·∫°o StorageManager v·ªõi 6 √¥ (0-5)
    // ‚ö†Ô∏è QUAN TR·ªåNG: addSlot TR∆Ø·ªöC, begin() SAU ƒë·ªÉ load d·ªØ li·ªáu v√†o slots
    // GPIO_NUM_1 d√πng t·∫°m cho test, ch∆∞a g·∫Øn LED th·∫≠t
    storage.addSlot(0, GPIO_NUM_2); // √î 0
    storage.addSlot(1, GPIO_NUM_2); // √î 1  
    storage.addSlot(2, GPIO_NUM_2); // √î 2
    storage.addSlot(3, GPIO_NUM_2); // √î 3
    storage.addSlot(4, GPIO_NUM_2); // √î 4
    storage.addSlot(5, GPIO_NUM_2); // √î 5
    
    // begin() s·∫Ω auto-load d·ªØ li·ªáu t·ª´ file v√†o c√°c slot ƒë√£ add
    if (!storage.begin("/storage/storage.json")) {
      ESP_LOGW(TAG, "Failed to initialize storage, but continuing...");
    }

    // ==================== STORAGE MANAGER MCP TOOLS ====================
    mcp.AddTool(
        "storage.put_item",
        "L∆ØU/ƒê·∫∂T ƒë·ªì v√†o m·ªôt √¥ c·ª• th·ªÉ trong t·ªß.\n"
        "D√πng khi: Ng∆∞·ªùi d√πng n√≥i 't√¥i ƒë·ªÉ [ƒë·ªì v·∫≠t] v√†o √¥ s·ªë [X]', 'c·∫•t [ƒë·ªì] "
        "v√†o ngƒÉn [X]'.\n"
        "Tham s·ªë:\n"
        "- slot (integer): S·ªë √¥ (0-5)\n"
        "- item (string): T√™n ƒë·ªì v·∫≠t (v√≠ d·ª•: 'k√≠nh', 'ch√¨a kh√≥a', 'v√≠')\n"
        "V√≠ d·ª•: Ng∆∞·ªùi d√πng: 'T√¥i ƒë·ªÉ k√≠nh v√†o √¥ s·ªë 4' ‚Üí slot=4, item='k√≠nh'\n"
        "Tr·∫£ v·ªÅ: true n·∫øu th√†nh c√¥ng, false n·∫øu √¥ kh√¥ng t·ªìn t·∫°i",
        PropertyList({Property("slot", kPropertyTypeInteger, 0, 5),
                      Property("item", kPropertyTypeString)}),
        [&storage](const PropertyList &props) -> ReturnValue {
          int slot = props["slot"].value<int>();
          std::string item = props["item"].value<std::string>();
          ESP_LOGI(TAG, "üì¶ Putting '%s' into slot %d", item.c_str(), slot);
          return storage.putItem(slot, item, true);
        });

    mcp.AddTool(
        "storage.take_item",
        "L·∫§Y ƒë·ªì ra kh·ªèi m·ªôt √¥ (ƒë√°nh d·∫•u √¥ tr·ªëng).\n"
        "D√πng khi: Ng∆∞·ªùi d√πng n√≥i 't√¥i l·∫•y ƒë·ªì ·ªü √¥ [X] ra', 'l·∫•y [ƒë·ªì] ra'.\n"
        "Tham s·ªë:\n"
        "- slot (integer): S·ªë √¥ c·∫ßn l·∫•y ƒë·ªì (0-5)\n"
        "Tr·∫£ v·ªÅ: true n·∫øu th√†nh c√¥ng, false n·∫øu √¥ kh√¥ng t·ªìn t·∫°i",
        PropertyList({Property("slot", kPropertyTypeInteger, 0, 5)}),
        [&storage](const PropertyList &props) -> ReturnValue {
          int slot = props["slot"].value<int>();
          ESP_LOGI(TAG, "üì§ Taking item from slot %d", slot);
          return storage.takeItem(slot, true);
        });

    mcp.AddTool(
        "storage.find_item",
        "T√åM KI·∫æM ƒë·ªì v·∫≠t trong t·ªß, tr·∫£ v·ªÅ danh s√°ch c√°c √¥ ch·ª©a ƒë·ªì ƒë√≥.\n"
        "D√πng khi: Ng∆∞·ªùi d√πng h·ªèi '[ƒë·ªì v·∫≠t] c·ªßa t√¥i ·ªü ƒë√¢u?', 't√¨m [ƒë·ªì]'.\n"
        "Tham s·ªë:\n"
        "- item (string): T√™n ƒë·ªì v·∫≠t c·∫ßn t√¨m\n"
        "V√≠ d·ª•: 'K√≠nh c·ªßa t√¥i ·ªü ƒë√¢u?' ‚Üí item='k√≠nh'\n"
        "Tr·∫£ v·ªÅ: Danh s√°ch s·ªë √¥ ch·ª©a ƒë·ªì ƒë√≥ (JSON array). N·∫øu kh√¥ng t√¨m th·∫•y "
        "‚Üí []",
        PropertyList({Property("item", kPropertyTypeString)}),
        [&storage](const PropertyList &props) -> ReturnValue {
          std::string item = props["item"].value<std::string>();
          ESP_LOGI(TAG, "üîç Finding item: %s", item.c_str());
          auto slots = storage.findItemByName(item);

          // T·∫°o JSON response
          cJSON *root = cJSON_CreateObject();
          cJSON_AddStringToObject(root, "item", item.c_str());
          cJSON *slotsArray = cJSON_CreateArray();
          for (int slot : slots) {
            cJSON_AddItemToArray(slotsArray, cJSON_CreateNumber(slot));
          }
          cJSON_AddItemToObject(root, "slots", slotsArray);
          cJSON_AddNumberToObject(root, "count", slots.size());

          char *jsonStr = cJSON_Print(root);
          std::string result(jsonStr);
          cJSON_free(jsonStr);
          cJSON_Delete(root);

          return result;
        });

    mcp.AddTool(
        "storage.led",
        "ƒêI·ªÄU KHI·ªÇN ƒê√àN LED c·ªßa m·ªôt √¥.\n"
        "Tham s·ªë:\n"
        "- slot (integer): S·ªë √¥ (0-5)\n"
        "- action (string): 'on' = b·∫≠t, 'off' = t·∫Øt, 'blink' = nh·∫•p nh√°y\n"
        "- times (integer): S·ªë l·∫ßn nh·∫•p nh√°y (ch·ªâ d√πng khi action='blink', m·∫∑c ƒë·ªãnh 3)\n"
        "- delay_ms (integer): ƒê·ªô tr·ªÖ ms (ch·ªâ d√πng khi action='blink', m·∫∑c ƒë·ªãnh 500)\n"
        "Tr·∫£ v·ªÅ: true n·∫øu th√†nh c√¥ng",
        PropertyList({Property("slot", kPropertyTypeInteger, 0, 5),
                      Property("action", kPropertyTypeString),
                      Property("times", kPropertyTypeInteger, 1, 10),
                      Property("delay_ms", kPropertyTypeInteger, 100, 2000)}),
        [&storage](const PropertyList &props) -> ReturnValue {
          int slot = props["slot"].value<int>();
          std::string action = props["action"].value<std::string>();
          
          if (action == "on") {
            ESP_LOGI(TAG, "üí° Turning ON LED for slot %d", slot);
            return storage.turnOnLED(slot);
          } else if (action == "off") {
            ESP_LOGI(TAG, "üåë Turning OFF LED for slot %d", slot);
            return storage.turnOffLED(slot);
          } else if (action == "blink") {
            int times = props["times"].value<int>();
            int delayMs = props["delay_ms"].value<int>();
            ESP_LOGI(TAG, "‚ú® Blinking LED for slot %d, %d times", slot, times);
            return storage.blinkLED(slot, times, delayMs);
          }
          return false;
        });

    mcp.AddTool(
        "storage.list_all",
        "XEM DANH S√ÅCH t·∫•t c·∫£ c√°c √¥ v√† ƒë·ªì v·∫≠t trong t·ªß.\n"
        "D√πng khi: Ng∆∞·ªùi d√πng h·ªèi 't·ªß c√≥ g√¨?', 'xem t·∫•t c·∫£ ƒë·ªì'.\n"
        "Kh√¥ng c·∫ßn tham s·ªë.\n"
        "Tr·∫£ v·ªÅ: Chu·ªói JSON ch·ª©a th√¥ng tin t·∫•t c·∫£ √¥ (index, status, item, "
        "...)",
        PropertyList(), [&storage](const PropertyList &) -> ReturnValue {
          std::string json = storage.getSlotsJSON();
          ESP_LOGI(TAG, "üìã Listing all storage slots %s", json.c_str());
          return json;
        });

    mcp.AddTool(
        "storage.get_info",
        "L·∫§Y TH√îNG TIN t·ªïng quan v·ªÅ t·ªß (s·ªë √¥ tr·ªëng, s·ªë √¥ c√≥ ƒë·ªì, t·ªïng s·ªë √¥).\n"
        "D√πng khi: C·∫ßn bi·∫øt t√¨nh tr·∫°ng t·ªß.\n"
        "Kh√¥ng c·∫ßn tham s·ªë.\n"
        "Tr·∫£ v·ªÅ: JSON object ch·ª©a total, empty, occupied",
        PropertyList(), [&storage](const PropertyList &) -> ReturnValue {
          cJSON *root = cJSON_CreateObject();
          cJSON_AddNumberToObject(root, "total", storage.getTotalSlotCount());
          cJSON_AddNumberToObject(root, "empty", storage.getEmptySlotCount());
          cJSON_AddNumberToObject(root, "occupied",
                                  storage.getOccupiedSlotCount());

          char *jsonStr = cJSON_Print(root);
          std::string result(jsonStr);
          cJSON_free(jsonStr);
          cJSON_Delete(root);

          ESP_LOGI(TAG, "‚ÑπÔ∏è Storage info: %s", result.c_str());
          return result;
        });

    // ==================== RECURRING SCHEDULE MCP TOOLS ====================

    mcp.AddTool(
        "schedule.add_once",
        "L·ªäCH CH·∫†Y 1 L·∫¶N duy nh·∫•t v√†o gi·ªù c·ª• th·ªÉ trong ng√†y h√¥m nay.\n"
        "D√πng khi: User mu·ªën nh·∫Øc 1 l·∫ßn (v√≠ d·ª•: 'nh·∫Øc h·ªçp l√∫c 3h chi·ªÅu', 'b·∫≠t "
        "ƒë√®n 8h t·ªëi').\n"
        "Tham s·ªë:\n"
        "- id (integer): ID duy nh·∫•t cho l·ªãch\n"
        "- hour (integer): Gi·ªù (0-23)\n"
        "- minute (integer): Ph√∫t (0-59)\n"
        "- note (string): L·ªánh s·∫Ω th·ª±c thi khi ƒë·∫øn gi·ªù\n"
        "Tr·∫£ v·ªÅ: true n·∫øu th√†nh c√¥ng",
        PropertyList({Property("id", kPropertyTypeInteger),
                      Property("hour", kPropertyTypeInteger, 0, 23),
                      Property("minute", kPropertyTypeInteger, 0, 59),
                      Property("note", kPropertyTypeString)}),
        [&scheduler, &app](const PropertyList &props) -> ReturnValue {
          int id = props["id"].value<int>();
          int hour = props["hour"].value<int>();
          int minute = props["minute"].value<int>();
          std::string note = props["note"].value<std::string>();

          ESP_LOGI(TAG, "‚è∞ Adding once schedule: id=%d, %02d:%02d, note=%s",
                   id, hour, minute, note.c_str());

          app.Schedule([&scheduler, id, hour, minute, note]() {
            scheduler.addOnceAtTime(id, hour, minute, note, true);
          });

          return true;
        });

    mcp.AddTool(
        "schedule.add_interval",
        "L·ªäCH L·∫∂P L·∫†I theo kho·∫£ng th·ªùi gian ƒë·ªÅu ƒë·∫∑n.\n"
        "D√πng khi: L·∫∑p sau m·ªói X ph√∫t/gi·ªù (v√≠ d·ª•: 'ki·ªÉm tra m·ªói 30 ph√∫t', "
        "'t∆∞·ªõi c√¢y 2 gi·ªù 1 l·∫ßn').\n"
        "Tham s·ªë:\n"
        "- id (integer): ID duy nh·∫•t\n"
        "- interval_seconds (integer): Kho·∫£ng th·ªùi gian (gi√¢y). VD: 30 ph√∫t = "
        "1800, 1 gi·ªù = 3600\n"
        "- note (string): L·ªánh th·ª±c thi m·ªói l·∫ßn\n"
        "Tr·∫£ v·ªÅ: true n·∫øu th√†nh c√¥ng",
        PropertyList({Property("id", kPropertyTypeInteger),
                      Property("interval_seconds", kPropertyTypeInteger),
                      Property("note", kPropertyTypeString)}),
        [&scheduler, &app](const PropertyList &props) -> ReturnValue {
          int id = props["id"].value<int>();
          int sec = props["interval_seconds"].value<int>();
          std::string note = props["note"].value<std::string>();
          uint32_t interval = static_cast<uint32_t>(sec);

          ESP_LOGI(TAG, "‚è∞ Adding interval schedule: id=%d, every %d seconds",
                   id, sec);

          app.Schedule([&scheduler, id, interval, note]() {
            scheduler.addIntervalSchedule(id, interval, note, true);
          });

          return true;
        });

    mcp.AddTool(
        "schedule.add_daily",
        "L·ªäCH H√ÄNG NG√ÄY v√†o c√πng gi·ªù m·ªói ng√†y.\n"
        "D√πng khi: L·∫∑p c√πng gi·ªù m·ªói ng√†y (v√≠ d·ª•: 'b√°o th·ª©c 6h30 s√°ng', 't·∫Øt "
        "ƒë√®n 10h t·ªëi').\n"
        "Tham s·ªë:\n"
        "- id (integer): ID duy nh·∫•t\n"
        "- hour (integer): Gi·ªù (0-23)\n"
        "- minute (integer): Ph√∫t (0-59)\n"
        "- note (string): L·ªánh th·ª±c thi h√†ng ng√†y\n"
        "Tr·∫£ v·ªÅ: true n·∫øu th√†nh c√¥ng",
        PropertyList({Property("id", kPropertyTypeInteger),
                      Property("hour", kPropertyTypeInteger, 0, 23),
                      Property("minute", kPropertyTypeInteger, 0, 59),
                      Property("note", kPropertyTypeString)}),
        [&scheduler, &app](const PropertyList &props) -> ReturnValue {
          int id = props["id"].value<int>();
          int hour = props["hour"].value<int>();
          int minute = props["minute"].value<int>();
          std::string note = props["note"].value<std::string>();

          std::vector<RecurringSchedule::DailyTime> times;
          times.emplace_back(hour, minute);

          ESP_LOGI(TAG, "‚è∞ Adding daily schedule: id=%d, %02d:%02d daily", id,
                   hour, minute);

          app.Schedule([&scheduler, id, times, note]() {
            scheduler.addDailySchedule(id, times, note, true);
          });

          return true;
        });

    mcp.AddTool(
        "schedule.add_weekly",
        "L·ªäCH H√ÄNG TU·∫¶N v√†o ng√†y v√† gi·ªù c·ªë ƒë·ªãnh.\n"
        "D√πng khi: L·∫∑p v√†o ng√†y c·ª• th·ªÉ trong tu·∫ßn (v√≠ d·ª•: 'h·ªçp m·ªói th·ª© 2 l√∫c "
        "9h').\n"
        "Tham s·ªë:\n"
        "- id (integer): ID duy nh·∫•t\n"
        "- weekday (string): MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, "
        "SATURDAY, SUNDAY\n"
        "- hour (integer): Gi·ªù (0-23)\n"
        "- minute (integer): Ph√∫t (0-59)\n"
        "- note (string): L·ªánh th·ª±c thi h√†ng tu·∫ßn\n"
        "Tr·∫£ v·ªÅ: true n·∫øu th√†nh c√¥ng",
        PropertyList({Property("id", kPropertyTypeInteger),
                      Property("weekday", kPropertyTypeString),
                      Property("hour", kPropertyTypeInteger, 0, 23),
                      Property("minute", kPropertyTypeInteger, 0, 59),
                      Property("note", kPropertyTypeString)}),
        [&scheduler, &app](const PropertyList &props) -> ReturnValue {
          int id = props["id"].value<int>();
          std::string wd = props["weekday"].value<std::string>();
          int hour = props["hour"].value<int>();
          int minute = props["minute"].value<int>();
          std::string note = props["note"].value<std::string>();

          RecurringSchedule::WeekDay day =
              (wd == "MONDAY")      ? RecurringSchedule::MONDAY
              : (wd == "TUESDAY")   ? RecurringSchedule::TUESDAY
              : (wd == "WEDNESDAY") ? RecurringSchedule::WEDNESDAY
              : (wd == "THURSDAY")  ? RecurringSchedule::THURSDAY
              : (wd == "FRIDAY")    ? RecurringSchedule::FRIDAY
              : (wd == "SATURDAY")  ? RecurringSchedule::SATURDAY
                                    : RecurringSchedule::SUNDAY;

          std::vector<RecurringSchedule::WeeklyTime> times;
          times.emplace_back(day, hour, minute);

          ESP_LOGI(TAG, "‚è∞ Adding weekly schedule: id=%d, %s %02d:%02d", id,
                   wd.c_str(), hour, minute);

          app.Schedule([&scheduler, id, times, note]() {
            scheduler.addWeeklySchedule(id, times, note, true);
          });

          return true;
        });

    mcp.AddTool(
        "schedule.remove",
        "X√ìA m·ªôt l·ªãch theo ID.\n"
        "D√πng khi: User mu·ªën h·ªßy l·ªãch.\n"
        "‚ö†Ô∏è L∆ØU √ù: PH·∫¢I g·ªçi 'schedule.list' tr∆∞·ªõc ƒë·ªÉ bi·∫øt ID, v√† X√ÅC NH·∫¨N "
        "v·ªõi user!\n"
        "Tham s·ªë:\n"
        "- id (integer): ID l·ªãch c·∫ßn x√≥a\n"
        "Tr·∫£ v·ªÅ: true n·∫øu th√†nh c√¥ng",
        PropertyList({Property("id", kPropertyTypeInteger)}),
        [&scheduler, &app](const PropertyList &props) -> ReturnValue {
          int id = props["id"].value<int>();

          ESP_LOGI(TAG, "üóëÔ∏è Removing schedule: id=%d", id);

          app.Schedule(
              [&scheduler, id]() { scheduler.removeSchedule(id, true); });

          return true;
        });

    mcp.AddTool(
        "schedule.list",
        "XEM DANH S√ÅCH t·∫•t c·∫£ l·ªãch ƒëang c√≥.\n"
        "D√πng khi: User h·ªèi 'c√≥ l·ªãch n√†o', 'xem l·ªãch', ho·∫∑c tr∆∞·ªõc khi x√≥a.\n"
        "Kh√¥ng c·∫ßn tham s·ªë.\n"
        "Tr·∫£ v·ªÅ: JSON ch·ª©a th√¥ng tin t·∫•t c·∫£ l·ªãch",
        PropertyList(), [&scheduler](const PropertyList &) -> ReturnValue {
          ESP_LOGI(TAG, "üìã Listing all schedules");
          return scheduler.getSchedulesJSON();
        });

    // ==================== END MCP TOOLS ====================

    // Light controls
    mcp.AddTool("light.power",
                "Ki·ªÉm tra tr·∫°ng th√°i ngu·ªìn ƒëi·ªán c·ªßa h·ªá th·ªëng ƒë√®n LED, tr·∫£ v·ªÅ "
                "true n·∫øu ƒë√®n ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng",
                PropertyList(),
                [this](const PropertyList &) -> ReturnValue { return true; });

    mcp.AddTool("light.sos",
                "ƒêi·ªÅu khi·ªÉn ch·∫ø ƒë·ªô ƒë√®n SOS kh·∫©n c·∫•p.\n"
                "Tham s·ªë:\n"
                "- action (string): 'on' = b·∫≠t SOS, 'off' = t·∫Øt SOS, 'status' = ki·ªÉm tra tr·∫°ng th√°i\n"
                "Tr·∫£ v·ªÅ: true/false t√πy action",
                PropertyList({Property("action", kPropertyTypeString)}),
                [this](const PropertyList &props) -> ReturnValue {
                  std::string action = props["action"].value<std::string>();
                  if (action == "on") {
                    is_sos_led_on = true;
                    return true;
                  } else if (action == "off") {
                    is_sos_led_on = false;
                    return false;
                  } else if (action == "status") {
                    return is_sos_led_on;
                  }
                  return false;
                });

    // Distance sensor
    mcp.AddTool("sensor.distance",
                "ƒêi·ªÅu khi·ªÉn c·∫£m bi·∫øn kho·∫£ng c√°ch d√≤ ƒë∆∞·ªùng.\n"
                "Tham s·ªë:\n"
                "- action (string): 'on' = b·∫≠t c·∫£m bi·∫øn, 'off' = t·∫Øt c·∫£m bi·∫øn, 'status' = ki·ªÉm tra tr·∫°ng th√°i\n"
                "Tr·∫£ v·ªÅ: true/false t√πy action",
                PropertyList({Property("action", kPropertyTypeString)}),
                [this](const PropertyList &props) -> ReturnValue {
                  std::string action = props["action"].value<std::string>();
                  if (action == "on") {
                    is_enable_distance = true;
                    return true;
                  } else if (action == "off") {
                    is_enable_distance = false;
                    return false;
                  } else if (action == "status") {
                    return is_enable_distance;
                  }
                  return false;
                });

    // System functions
    mcp.AddTool(
        "system.gps",
        "L·∫•y v·ªã tr√≠ GPS hi·ªán t·∫°i c·ªßa thi·∫øt b·ªã v√† t·∫°o link Google Maps ƒë·ªÉ xem "
        "v·ªã tr√≠. "
        "Tr·∫£ v·ªÅ ƒë∆∞·ªùng link d·∫°ng http://maps.google.com/?q=lat,lon c√≥ th·ªÉ m·ªü "
        "tr√™n tr√¨nh duy·ªát. "
        "N·∫øu t·ªça ƒë·ªô lat/lon = 0 nghƒ©a l√† ch∆∞a b·∫Øt ƒë∆∞·ª£c t√≠n hi·ªáu GPS, khuy√™n "
        "ng∆∞·ªùi d√πng ra khu v·ª±c th√¥ng tho√°ng. "
        "D√πng ƒë·ªÉ x√°c ƒë·ªãnh v·ªã tr√≠ hi·ªán t·∫°i, chia s·∫ª ƒë·ªãa ƒëi·ªÉm ho·∫∑c t√¨m ƒë∆∞·ªùng",
        PropertyList(), [this](const PropertyList &) -> ReturnValue {
          latitude = 10.036935;
          longitude = 105.761735;
          sprintf(gps_link, "http://maps.google.com/?q=%.05f,%.05f", latitude,
                  longitude);
          return gps_link;
        });

    mcp.AddTool("system.wifi_reset",
                "Kh·ªüi ƒë·ªông l·∫°i thi·∫øt b·ªã v√† v√†o ch·∫ø ƒë·ªô c·∫•u h√¨nh WiFi ƒë·ªÉ k·∫øt n·ªëi "
                "m·∫°ng m·ªõi. "
                "**C·∫¢NH B√ÅO**: H√†nh ƒë·ªông n√†y s·∫Ω ng·∫Øt k·∫øt n·ªëi hi·ªán t·∫°i v√† y√™u "
                "c·∫ßu c·∫•u h√¨nh l·∫°i WiFi. "
                "Ch·ªâ s·ª≠ d·ª•ng khi c·∫ßn thay ƒë·ªïi m·∫°ng WiFi ho·∫∑c kh·∫Øc ph·ª•c s·ª± c·ªë "
                "k·∫øt n·ªëi. C·∫ßn x√°c nh·∫≠n t·ª´ ng∆∞·ªùi d√πng",
                PropertyList(), [](const PropertyList &) -> ReturnValue {
                  ESP_LOGW(TAG, "WiFi reset requested");
                  // SwitchNetworkType();
                  return true;
                });

    // Telegram functions
    mcp.AddTool("msg.check",
                "Ki·ªÉm tra v√† ƒë·ªçc tin nh·∫Øn m·ªõi t·ª´ Telegram bot. Tr·∫£ v·ªÅ n·ªôi dung "
                "JSON ch·ª©a c√°c tin nh·∫Øn ch∆∞a ƒë·ªçc "
                "bao g·ªìm ng∆∞·ªùi g·ª≠i, th·ªùi gian, n·ªôi dung tin nh·∫Øn. N·∫øu c√≥ tin "
                "nh·∫Øn m·ªõi s·∫Ω ƒë·ªçc l·∫ßn l∆∞·ª£t t·ª´ng tin. "
                "D√πng ƒë·ªÉ nh·∫≠n th√¥ng b√°o, tin nh·∫Øn t·ª´ ng∆∞·ªùi th√¢n ho·∫∑c h·ªá th·ªëng "
                "gi√°m s√°t t·ª´ xa",
                PropertyList(), [&app](const PropertyList &) -> ReturnValue {
                  return app.GetTelegramMsgBufferAsJson();
                });

    mcp.AddTool(
        "msg.send",
        "G·ª≠i tin nh·∫Øn text qua Telegram bot ƒë·∫øn chat/group ƒë√£ c·∫•u h√¨nh. "
        "Tham s·ªë msg: n·ªôi dung tin nh·∫Øn c·∫ßn g·ª≠i (h·ªó tr·ª£ ti·∫øng Vi·ªát v√† "
        "emoji). "
        "D√πng ƒë·ªÉ b√°o c√°o t√¨nh tr·∫°ng, g·ª≠i th√¥ng b√°o kh·∫©n c·∫•p, ho·∫∑c li√™n l·∫°c "
        "v·ªõi "
        "ng∆∞·ªùi th√¢n. "
        "Tin nh·∫Øn s·∫Ω ƒë∆∞·ª£c g·ª≠i ngay l·∫≠p t·ª©c n·∫øu c√≥ k·∫øt n·ªëi internet",
        PropertyList({Property("msg", kPropertyTypeString)}),
        [&app](const PropertyList &props) -> ReturnValue {
          app.SendTelegramMessage(props["msg"].value<std::string>());
          return true;
        });

    // Camera functions (if available)
    if (camera_) {
      mcp.AddTool(
          "camera.photo",
          "Ch·ª•p ·∫£nh b·∫±ng camera t√≠ch h·ª£p v√† t·ª± ƒë·ªông g·ª≠i qua Telegram bot. "
          "Kh√¥ng c·∫ßn tham s·ªë ƒë·∫ßu v√†o, h·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông ch·ª•p, n√©n v√† g·ª≠i "
          "·∫£nh "
          "v·ªõi ch·∫•t l∆∞·ª£ng t·ªëi ∆∞u. "
          "S·ª≠ d·ª•ng khi ng∆∞·ªùi d√πng y√™u c·∫ßu ch·ª•p ·∫£nh g·ª≠i cho ng∆∞·ªùi th√¢n, ghi "
          "l·∫°i "
          "s·ª± ki·ªán, "
          "ho·∫∑c chia s·∫ª h√¨nh ·∫£nh m√¥i tr∆∞·ªùng xung quanh. C·∫ßn k·∫øt n·ªëi internet "
          "ƒë·ªÉ g·ª≠i ·∫£nh",
          PropertyList(),
          [this, &telegram](const PropertyList &) -> ReturnValue {
            // if (!camera_->Capture())
            //   return false;

            // TelegramPhotoInfo info;
            // auto config = telegram.GetConfig();

            // if (!config.chat_id.empty() && !config.bot_token.empty()) {
            //   info = {config.bot_token, config.chat_id, "", ""};
            // } else {
            //   info = {"7354122596:AAFVA3MTxPZwCwmDPJNBvbchMe3ZlHvyjqU",
            //           "7799806969", "", ""};
            // }

            // return camera_->SendPhotoToTelegram(info);

            auto &app = Application::GetInstance();

            app.Schedule([this]() {
              if (!camera_->Capture()) {
                throw std::runtime_error("Failed to capture photo");
              }

              ESP_LOGI(TAG, "Captured photo, sending to Telegram...");
              // auto question = properties["question"].value<std::string>();
              TelegramPhotoInfo info;

              // Load configuration from TelegramManager if parameters are
              // empty
              auto &telegram_manager = TelegramManager::GetInstance();
              auto config = telegram_manager.GetConfig();

              info.caption = "";
              info.parse_mode = ""; // ho·∫∑c "" n·∫øu kh√¥ng d√πng

              if (!config.chat_id.empty() && !config.bot_token.empty()) {
                ESP_LOGI(TAG, "Loaded bot token from TelegramManager");
                info.bot_token = config.bot_token;
                info.chat_id = config.chat_id;
              } else {
                ESP_LOGW(TAG,
                         "Telegram bot not configured, using default test bot");
                info.bot_token =
                    "7354122596:AAFVA3MTxPZwCwmDPJNBvbchMe3ZlHvyjqU";
                info.chat_id = "7799806969"; // group/supergroup
              }
              return camera_->SendPhotoToTelegram(info);
            });

            return true;
          });

      mcp.AddTool(
          "camera.analyze",
          "Ch·ª•p ·∫£nh v√† ph√¢n t√≠ch n·ªôi dung b·∫±ng AI ƒë·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi v·ªÅ h√¨nh "
          "·∫£nh. "
          "Tham s·ªë question: c√¢u h·ªèi v·ªÅ nh·ªØng g√¨ mu·ªën bi·∫øt trong ·∫£nh (VD: "
          "'c√≥ "
          "g√¨ trong ·∫£nh?', 'ƒë√¢y l√† m·ªánh gi√° ti·ªÅn bao nhi√™u?', 'ƒë·ªçc ch·ªØ trong "
          "·∫£nh'). "
          "AI c√≥ th·ªÉ nh·∫≠n di·ªán v·∫≠t th·ªÉ, ƒë·ªçc vƒÉn b·∫£n, nh·∫≠n di·ªán ti·ªÅn t·ªá, m√¥ "
          "t·∫£ "
          "c·∫£nh v·∫≠t, ƒë·∫øm s·ªë l∆∞·ª£ng ƒë·ªì v·∫≠t. "
          "H·ªØu √≠ch cho ng∆∞·ªùi khi·∫øm th·ªã ƒë·ªÉ 'nh√¨n' v√† hi·ªÉu m√¥i tr∆∞·ªùng xung "
          "quanh",
          PropertyList({Property("question", kPropertyTypeString)}),
          [this](const PropertyList &props) -> ReturnValue {
            if (!camera_->Capture())
              return "L·ªói ch·ª•p ·∫£nh";
            return camera_->Explain(props["question"].value<std::string>());
          });
    }
  }

  // void InitializeTools() {

  //   static LampController lamp(SOS_LED_PIN);

  //   auto &mcp_server = McpServer::GetInstance();
  //   // auto &board = Board::GetInstance();

  //   mcp_server.AddTool(
  //       "self.light.get_power", "Ëé∑ÂèñÁÅØÊòØÂê¶ÊâìÂºÄ", PropertyList(),
  //       [this](const PropertyList &properties) -> ReturnValue { return true;
  //       });

  //   mcp_server.AddTool("self.light.sos",
  //                      "b·∫≠t t·∫Øt ch·ª©c nƒÉng ƒë√®n SOS nh·∫•p nh√°y li√™n t·ª•c",
  //                      PropertyList({Property("sos_on",
  //                      kPropertyTypeBoolean)}), [this](const PropertyList
  //                      &properties) -> ReturnValue {
  //                        is_sos_led_on = properties["sos_on"].value<bool>();
  //                        ESP_LOGI(TAG, "Set sos led to: %d", is_sos_led_on);
  //                        return is_sos_led_on;
  //                      });

  //   mcp_server.AddTool("self.light.get_sos_status",
  //                      "ki·ªÉm tra tr·∫°ng th√°i ƒë√®n SOS ƒëang b·∫≠t hay t·∫Øt",
  //                      PropertyList(),
  //                      [this](const PropertyList &properties) -> ReturnValue
  //                      {
  //                        ESP_LOGI(TAG, "Get sos led status: %d",
  //                        is_sos_led_on); return is_sos_led_on;
  //                      });

  //   mcp_server.AddTool(
  //       "self.system.get_gps",
  //       "ki·ªÉm tra v·ªã tr√≠ hi·ªán t·∫°i c·ªßa thi·∫øt b·ªã, thi·∫øt b·ªã s·∫Ω tr·∫£ v·ªÅ ƒë∆∞·ªùng link
  //       " "c·ªßa google map, ki·ªÉm tra l·∫°i v·ªã tr√≠ tr√™n google map ho·∫∑c d√πng c√°i
  //       n√†o " "c≈©ng ƒë∆∞·ª£c. m·ª•c ƒë√≠ch l·∫•y ƒë∆∞·ª£c v·ªã tr√≠ d·∫°ng t√™n ƒë∆∞·ªùng, ph∆∞·ªùng x√£,
  //       th√†nh " "ph·ªë, qu·ªëc gia, n·∫øu v·ªã tr√≠ lat lon ƒë·ªÅu b·∫±ng 0 th√¨ ch∆∞a c√≥ v·ªã
  //       tr√≠ gps " "khuy√™n ng∆∞·ªùi d√πng ra ngo√†i khu v·ª±c th√¥ng tho√°ng",
  //       PropertyList(), [this](const PropertyList &properties) -> ReturnValue
  //       {
  //         latitude = 10.036935;
  //         longitude = 105.761735;

  //         sprintf(gps_link, "http://maps.google.com/?q=%.05f,%.05f",
  //         latitude,
  //                 longitude);

  //         // std::string gps_str = get_address_latlon(latitude, longitude);
  //         // ESP_LOGI(TAG, "Get gps link: %s", gps_link.c_str());

  //         return gps_link;
  //       });

  //   mcp_server.AddTool(
  //       "self.light.turn_on_distance",
  //       "ƒë√¢y l√† h√†m ra l·ªánh t·∫Øt ho·∫∑c m·ªü ch·ª©c nƒÉng d√≤ ƒë∆∞·ªùng d√πng "
  //       "c·∫£m bi·∫øn kho·∫£ng c√°ch ƒë·ªÉ ƒëo, ph√°t rung th√¥ng b√°o khi c√≥ v·∫≠t c·∫£n ·ªü
  //       g·∫ßn", PropertyList({Property("vibrate", kPropertyTypeBoolean)}),
  //       [this](const PropertyList &properties) -> ReturnValue {
  //         //  return led_on_;
  //         is_enable_distance = properties["vibrate"].value<bool>();
  //         ESP_LOGI(TAG, "Set distance sensor vibrate to: %d",
  //                  is_enable_distance);
  //         return is_enable_distance;
  //       });

  //   mcp_server.AddTool(
  //       "self.light.get_distance_status",
  //       "ki·ªÉm tra tr·∫°ng th√°i c·∫£m bi·∫øn kho·∫£ng c√°ch ƒëang b·∫≠t hay t·∫Øt",
  //       PropertyList(), [this](const PropertyList &properties) -> ReturnValue
  //       {
  //         ESP_LOGI(TAG, "Get distance sensor vibrate status: %d",
  //                  is_enable_distance);
  //         return is_enable_distance;
  //       });

  //   mcp_server.AddTool(
  //       "self.system.reconfigure_wifi",
  //       "Reboot the device and enter WiFi configuration mode.\n"
  //       "**CAUTION** You must ask the user to confirm this action.",
  //       PropertyList(), [this](const PropertyList &properties) {
  //         // ResetWifiConfiguration();
  //         // print to debug

  //         ESP_LOGW(TAG, "Rebooting to enter WiFi configuration mode");
  //         return true;
  //       });

  //   mcp_server.AddTool("self.system.checkMsg",
  //                      "ki·ªÉm tra tin nh·∫Øn t·ª´ telegram xem c√≥ tin nh·∫Øn m·ªõi "
  //                      "kh√¥ng n·∫øu c√≥ th√¨ ƒë·ªçc n·ªôi dung tin nh·∫Øn l√™n. ƒë·ªçc l·∫ßn "
  //                      "l∆∞·ª£t n·ªôi dung tin nh·∫Øn \n ",
  //                      PropertyList(), [this](const PropertyList &properties)
  //                      {
  //                        ESP_LOGW(TAG, "new msg from telegram, reading
  //                        now...");

  //                        auto &app = Application::GetInstance();
  //                        return app.GetTelegramMsgBufferAsJson();
  //                      });

  //   mcp_server.AddTool(
  //       "self.screen.sendMsg",
  //       "g·ª≠i tin nh·∫Øn.\n"
  //       "**CAUTION** tr·∫£ v·ªÅ n·ªôi dung tin nh·∫Øn mu·ªën g·ª≠i.",
  //       PropertyList({Property("msg", kPropertyTypeString)}),
  //       [](const PropertyList &properties) -> ReturnValue {
  //         // display->SetTheme(
  //         //     properties["msg"].value<std::string>().c_str());

  //         std::string msg = properties["msg"].value<std::string>();
  //         ESP_LOGI(TAG, "Message to send to Telegram: %s", msg.c_str());

  //         // G·ª≠i tin nh·∫Øn qua Telegram bot
  //         auto &app = Application::GetInstance();
  //         app.SendTelegramMessage(msg);
  //         return true;
  //       });

  //   if (camera_) {

  //     mcp_server.AddTool(
  //         "self.camera.take_photo",
  //         "Take a photo and send it. Use this tool after the user asks you "
  //         "to send image to others. this tool will automation send\n",
  //         PropertyList(),
  //         [this](const PropertyList &properties) -> ReturnValue {
  //           if (!camera_->Capture()) {
  //             throw std::runtime_error("Failed to capture photo");
  //           }

  //           ESP_LOGI(TAG, "Captured photo, sending to Telegram...");
  //           // auto question = properties["question"].value<std::string>();
  //           TelegramPhotoInfo info;

  //           // Load configuration from TelegramManager if parameters are
  //           empty auto &telegram_manager = TelegramManager::GetInstance();
  //           auto config = telegram_manager.GetConfig();

  //           info.caption = "";
  //           info.parse_mode = ""; // ho·∫∑c "" n·∫øu kh√¥ng d√πng

  //           if (!config.chat_id.empty() && !config.bot_token.empty()) {
  //             ESP_LOGI(TAG, "Loaded bot token from TelegramManager");
  //             info.bot_token = config.bot_token;
  //             info.chat_id = config.chat_id;
  //           } else {
  //             ESP_LOGW(TAG,
  //                      "Telegram bot not configured, using default test
  //                      bot");
  //             info.bot_token =
  //             "7354122596:AAFVA3MTxPZwCwmDPJNBvbchMe3ZlHvyjqU"; info.chat_id
  //             = "7799806969"; // group/supergroup
  //           }

  //           return camera_->SendPhotoToTelegram(info);
  //         });

  //     mcp_server.AddTool(
  //         "self.camera.eyes",
  //         "h·ªèi v·ªÅ c√≥ nh√¨n th·∫•y ho·∫∑c c√≥ nh·∫≠n di·ªán ƒë∆∞·ª£c g√¨ trong ·∫£nh kh√¥ng. C√≥
  //         " "th·ªÉ" "y√™u c·∫ßu nh·∫≠n di·ªán ti·ªÅn. m·ªánh gi√° ti·ªÅn, y√™u c·∫ßu ƒë·ªçc ch·ªØ t·ª´
  //         nhi·ªÅu " "ngu·ªìn. nh·∫≠n di·ªán v·∫≠t th·ªÉ\n" "Args:\n" "  `question`: The
  //         question that you want to ask about the photo.\n" "Return:\n" "  A
  //         JSON object that provides the photo information.",
  //         PropertyList({Property("question", kPropertyTypeString)}),
  //         [this](const PropertyList &properties) -> ReturnValue {
  //           if (!camera_->Capture()) {
  //             throw std::runtime_error("Failed to capture photo");
  //           }
  //           auto question = properties["question"].value<std::string>();
  //           return camera_->Explain(question);
  //         });
  //   }
  // }

  static void gps_event_handler(void *event_handler_arg,
                                esp_event_base_t event_base, int32_t event_id,
                                void *event_data) {
    gps_t *gps = NULL;
    switch (event_id) {
    case GPS_UPDATE:
      gps = (gps_t *)event_data;

      latitude = gps->latitude;
      longitude = gps->longitude;

      if (latitude != last_latitude && longitude != last_longitude &&
          latitude > 0 && longitude > 0) {
        last_latitude = latitude;
        last_longitude = longitude;
      } else {
        latitude = last_latitude;
        longitude = last_longitude;
      }
      // 10.036935, 105.761735
      // latitude = 10.036935;
      // longitude = 105.761735;

      sprintf(gps_link, "http://maps.google.com/?q=%.05f,%.05f", latitude,
              longitude);

      if (latitude > 0 && longitude > 0 && !is_speak_gps) {
        // send_json_via_ws(ask_weather, gps_link);
        is_speak_gps = true;
        // start_play_mp3_task(mp3_gps);
      }

      // sprintf(gps_link, "http://maps.google.com/?q=%.05f,%.05f", latitude,
      //         longitude);
      // gps_link
      /* print information parsed from GPS statements */
      // ESP_LOGI(TAG,
      //          "%d/%d/%d %d:%d:%d => \r\n"
      //          "\t\t\t\t\t\tlatitude   = %.05f¬∞N\r\n"
      //          "\t\t\t\t\t\tlongitude = %.05f¬∞E\r\n"
      //          "\t\t\t\t\t\taltitude   = %.02fm\r\n"
      //          "\t\t\t\t\t\tspeed      = %fm/s",
      //          gps->date.year + YEAR_BASE, gps->date.month, gps->date.day,
      //          gps->tim.hour + TIME_ZONE, gps->tim.minute, gps->tim.second,
      //          gps->latitude, gps->longitude, gps->altitude, gps->speed);
      break;
    case GPS_UNKNOWN:
      /* print unknown statements */
      // ESP_LOGW(TAG, "%s", (char *)event_data);
      break;
    default:
      break;
    }
  }

  static void distance_uart_setup() {
    // C·∫•u h√¨nh UART
    uart_config_t uart_config = {
        .baud_rate = distance_uart_baudrate,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_APB,
    };

    uart_param_config(distance_uart_port, &uart_config);
    // C·∫•u h√¨nh ch√¢n: ch·ªâ d√πng RX (ch√¢n TX gi·ªØ nguy√™n ho·∫∑c kh√¥ng d√πng)
    uart_set_pin(distance_uart_port, distance_uart_tx_pin, distance_uart_rx_pin,
                 UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    uart_driver_install(distance_uart_port, distance_uart_buff_size * 2, 0, 0,
                        NULL, 0);
  }

  static void vibrate(int times) {
    for (int i = 0; i < times; i++) {
      gpio_set_level(VABRITE_PIN, 1);
      vTaskDelay(pdMS_TO_TICKS(300));
      gpio_set_level(VABRITE_PIN, 0);
      vTaskDelay(pdMS_TO_TICKS(300));
    }
  }

  static void distance_uart_read_task(void *pvParameters) {
    distance_uart_setup();
    // gpio_set_level(VABRITE_PIN, 1);
    while (1) {
      uint8_t *data = (uint8_t *)malloc(distance_uart_buff_size);
      int len = uart_read_bytes(distance_uart_port, data,
                                distance_uart_buff_size, pdMS_TO_TICKS(100));
      if (len == 8) {
        // Ki·ªÉm tra header
        if (data[0] != 0x5A) {
          // ESP_LOGW(TAG, "Header kh√¥ng h·ª£p l·ªá: 0x%02X", data[0]);
          free(data);
          continue;
        }

        uint8_t sum = 0;
        for (int i = 0; i < 7; i++) {
          sum += data[i];
        }

        if (sum == data[7]) {
          uint16_t distance = ((uint16_t)data[4] << 8) | data[5];
          uint8_t info = data[6];
          uint8_t RangeStatus = (info >> 4) & 0x0F;
          // uint8_t Time = (info >> 2) & 0x03;  // Unused
          // uint8_t Mode = info & 0x03;  // Unused

          if (RangeStatus != 2) {
            // ESP_LOGI(TAG,
            //          "Distance: %d mm, RangeStatus: %d, Time: %d, Mode: % d
            //          ", distance, RangeStatus, Time, Mode);

            if (is_enable_distance && distance < 1000) {
              // TickType_t current_tick = xTaskGetTickCount();
              vibrate(1);
            }
          } else {
            // ESP_LOGI(TAG, "Out Of Range");
          }
        } else {
          // ESP_LOGW(TAG, "Checksum kh√¥ng kh·ªõp. Expected: 0x%02X, Received:
          // 0x%02X",
          //          sum, data[7]);
        }
        vTaskDelay(pdMS_TO_TICKS(1));
      }
      free(data);
    }
  }

  void setup_task_distance_uart() {
    xTaskCreate(distance_uart_read_task, "distance_uart_read_task", 4096, NULL,
                10, NULL);
  }

  void setup_gps() {
    /* NMEA parser configuration */
    nmea_parser_config_t config = NMEA_PARSER_CONFIG_DEFAULT();
    /* init NMEA parser library */
    nmea_parser_handle_t nmea_hdl = nmea_parser_init(&config);
    /* register event handler for NMEA parser library */
    nmea_parser_add_handler(nmea_hdl, gps_event_handler, NULL);
    ESP_LOGI(TAG, "GPS initialized");
  }

  void blink(int times) {
    for (int i = 0; i < times; i++) {
      gpio_set_level(SOS_LED_PIN, 1);
      vTaskDelay(pdMS_TO_TICKS(200));
      gpio_set_level(SOS_LED_PIN, 0);
      vTaskDelay(pdMS_TO_TICKS(200));
    }
  }

  void setup_pins() {
    gpio_reset_pin(SOS_LED_PIN);
    gpio_set_direction(SOS_LED_PIN, GPIO_MODE_OUTPUT);
    blink(3);

    gpio_reset_pin(VABRITE_PIN);
    gpio_set_direction(VABRITE_PIN, GPIO_MODE_OUTPUT);
    vibrate(2);

    // gpio_set_level(VABRITE_PIN, 1);
  }

public:
  Esp32S3CamGpsA7680cBoard()
      : DualNetworkBoard(ML307_TX_PIN, ML307_RX_PIN, GPIO_NUM_NC, 1),
        capture_button_(CAPTURE_BUTTON_GPIO, false, 2000, 50, false),
        mode_button_(MODE_BUTTON_GPIO, false, 2000, 50, false),
        send_button_(SEND_BUTTON_GPIO, false, 2000, 50, false) {
    MountStorage();
    InitializeDisplayI2c();
    InitializeSsd1306Display();
    InitializeButtons();
    InitializeTools();
    InitializeCamera();
    // setup_gps();
    // setup_task_distance_uart();
    setup_pins();
  }

  virtual Led *GetLed() override {
    static SingleLed led(SOS_LED_PIN);
    return &led;
  }

  virtual AudioCodec *GetAudioCodec() override {
    static AdcI2sAudioCodec audio_codec(
        AUDIO_INPUT_SAMPLE_RATE,     // 16000 Hz ADC input
        AUDIO_OUTPUT_SAMPLE_RATE,    // 24000 Hz I2S output
        AUDIO_ADC_MIC_CHANNEL,       // ADC1_CHANNEL_6 (GPIO47)
        AUDIO_I2S_GPIO_BCLK,         // I2S Bit Clock (GPIO39)
        AUDIO_I2S_GPIO_WS,           // I2S Word Select (GPIO21)
        AUDIO_I2S_GPIO_DOUT,         // I2S Data Out (GPIO48)
        AUDIO_I2S_GPIO_DIN);         // I2S Data In (GPIO47, unused for output-only)
    return &audio_codec;
  }

  virtual Display *GetDisplay() override { return display_; }

  virtual Camera *GetCamera() override { return camera_; }
};

DECLARE_BOARD(Esp32S3CamGpsA7680cBoard);